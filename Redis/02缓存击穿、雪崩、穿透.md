## 缓存雪崩解决方案

- 笨办法1：加随机时间

​	处理缓存雪崩简单，在批量往**Redis**存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效

`setRedis（Key，value，time + Math.random() *10000);` 

- 笨办法2：永不过期，采用适当的内存淘汰策略（如LRU）

- 将热点数据分布到不同的master当中去

## 缓存穿透解决方案

- 代码中校验

  比如：在MySQL中id都是大于0的，但是我请求id小于0的，肯定查不到东西，并且缓存中也不可能放，所以首先考虑代码中进行提升鲁棒性

- redis写null值
- 布隆过滤器

## 缓存击穿解决方案

- 互斥锁，不要让请求都去请求MySQL
- 笨办法1：数据永不过期



​	当然，redis本身进行高可用部署也有必要，比如主从复制，master集群，sentinel，备份