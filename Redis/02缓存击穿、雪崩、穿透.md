## 缓存雪崩解决方案

- 笨办法1：加随机时间

​	处理缓存雪崩简单，在批量往**Redis**存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效

`setRedis（Key，value，time + Math.random() *10000);` 

- 笨办法2：永不过期，采用适当的内存淘汰策略（如LRU）

- 将热点数据分布到不同的master当中去
- **自动续期**：每当用户请求到来，数据缓存命中后，判断当前时间是否处于续期区间内（例如，10秒），如果是则异步线程自动发起一次查询并更新续期缓存的过期时间。用户请求对续期过程完全不感知，也不会有时延上的损耗。结果就是，对于热点缓存数据的请求，缓存永远都会命中且不会过期，解决了时延抖动问题；而非热点的缓存数据，即使缓存不命中而时延抖动，也属于可接受的场景。

## 缓存穿透解决方案

- 代码中校验

  比如：在MySQL中id都是大于0的，但是我请求id小于0的，肯定查不到东西，并且缓存中也不可能放，所以首先考虑代码中进行提升鲁棒性

- redis写null值
- 布隆过滤器
- 限制ip访问，如若一分钟某IP访问非法请求量大于80%，则限制其请求

## 缓存击穿解决方案

- 互斥锁，不要让请求都去请求MySQL
- 笨办法1：数据永不过期



​	当然，redis本身进行高可用部署也有必要，比如主从复制，master集群，sentinel，备份